<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>minerva: Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">minerva
   &#160;<span id="projectnumber">v1.0.0</span>
   </div>
   <div id="projectbrief">GPGPU computing framework using the Vulkan API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_quickstart.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quick Start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We assume you already have a compute shader. In the following is shown a quick start guide on how to get it running using <code>minerva</code>.</p>
<p>We'll be using the compute shader from the add example:</p>
<div class="fragment"><div class="line">#version 460</div>
<div class="line"> </div>
<div class="line">layout(local_size_x = 1) in;</div>
<div class="line"> </div>
<div class="line">layout(binding = 0) readonly buffer tensorA { int in_a[]; };</div>
<div class="line">layout(binding = 1) readonly buffer tensorB { int in_b[]; };</div>
<div class="line">layout(binding = 2) writeonly buffer tensorOut { int out_c[]; };</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    uint idx = gl_GlobalInvocationID.x;</div>
<div class="line">    out_c[idx] = in_a[idx] + in_b[idx];</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
0. Compiling the Shader</h1>
<p>If not already done, the first step should be to compile the shader to SPIR-V. <code>minerva</code> targets Vulkan 1.2 so compiling a compute shader <code>compute.comp</code> using <code>glslc</code> might look like the following:</p>
<div class="fragment"><div class="line">glslc compute.comp -o compute.spv --target-env=vulkan1.2 -O</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
1. Creating a context</h1>
<p>To do anything you first need to create a context. A context holds common objects needed by <code>minerva</code> to interact with Vulkan. Context can be created from an instance so let's start with that:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> instance = <a class="code" href="group__core.html#gac0dddb3e4179d1e5efe857568f216819">minerva::createInstance</a>();</div>
<div class="ttc" id="agroup__core_html_gac0dddb3e4179d1e5efe857568f216819"><div class="ttname"><a href="group__core.html#gac0dddb3e4179d1e5efe857568f216819">minerva::createInstance</a></div><div class="ttdeci">InstanceHandle createInstance()</div><div class="ttdoc">Create a Instance.</div></div>
</div><!-- fragment --><p>One could now get all installed devices on the system that can support <code>minerva</code> which is essentially any graphics cards since 2012. Most of the time either only one GPU is installed anyway or there's an integrated and a discrete one. To select the discrete one if there is one and create a context, it's enough to call</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> context = <a class="code" href="group__core.html#ga7b1f962be9d0a1432b5f4beb2088da4a">minerva::createContext</a>(instance);</div>
<div class="ttc" id="agroup__core_html_ga7b1f962be9d0a1432b5f4beb2088da4a"><div class="ttname"><a href="group__core.html#ga7b1f962be9d0a1432b5f4beb2088da4a">minerva::createContext</a></div><div class="ttdeci">ContextHandle createContext(const InstanceHandle &amp;instance, const Device &amp;device)</div><div class="ttdoc">Create a Context object.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
2. Allocate Memory</h1>
<p>Next up is to allocate the memory we want to use. In the example code we have three storage buffer objects. They're counterparts in <code>minerva</code> is <code>Tensor</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classminerva_1_1_tensor.html">minerva::Tensor&lt;uint32_t&gt;</a> tensor1(context, 10);</div>
<div class="line"><a class="code" href="classminerva_1_1_tensor.html">minerva::Tensor&lt;uint32_t&gt;</a> tensor2(context, 10);</div>
<div class="line"><a class="code" href="classminerva_1_1_tensor.html">minerva::Tensor&lt;uint32_t&gt;</a> tensor3(context, 10);</div>
<div class="ttc" id="aclassminerva_1_1_tensor_html"><div class="ttname"><a href="classminerva_1_1_tensor.html">minerva::Tensor</a></div><div class="ttdoc">Tensor managing memory on the GPU presented as an array of type T.</div><div class="ttdef"><b>Definition:</b> Tensor.hpp:44</div></div>
</div><!-- fragment --><p>Since this tensors live on the GPU, we can't directly access their memory. Instead we need a counterpart on the CPU side, called <code>Buffer</code>, which are generally used to stage and retrieve data from GPU local memory. First, let's create them:</p>
<div class="fragment"><div class="line"><a class="code" href="classminerva_1_1_buffer.html">minerva::Buffer&lt;uint32_t&gt;</a> buffer1(context, { 15, 36, 51, 12, 99, 102, 12, 33, 54, 22 });</div>
<div class="line"><a class="code" href="classminerva_1_1_buffer.html">minerva::Buffer&lt;uint32_t&gt;</a> buffer2(context, { 13, 12, 28, 23, 94, 56, 72, 28, 44, 13 });</div>
<div class="line"><a class="code" href="classminerva_1_1_buffer.html">minerva::Buffer&lt;uint32_t&gt;</a> buffer3(context, 10);</div>
<div class="ttc" id="aclassminerva_1_1_buffer_html"><div class="ttname"><a href="classminerva_1_1_buffer.html">minerva::Buffer</a></div><div class="ttdoc">Buffer managing memory hosted by the CPU presented as an array of type T.</div><div class="ttdef"><b>Definition:</b> Buffer.hpp:61</div></div>
</div><!-- fragment --><p>To copy data back and forth from the GPU, we need create commands. Commands hold instructions for the driver to execute at a latter time, so creating these commands do not execute them immediately. We see how to do so later on. Right now, let's create commands for copying the data:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> copy1 = <a class="code" href="group__memory.html#gabd431c08dce9b0b8cd96434a8554e99b">minerva::updateTensor</a>(buffer1, tensor1);</div>
<div class="line"><span class="keyword">auto</span> copy2 = <a class="code" href="group__memory.html#gabd431c08dce9b0b8cd96434a8554e99b">minerva::updateTensor</a>(buffer2, tensor2);</div>
<div class="line"><span class="keyword">auto</span> copy3 = <a class="code" href="group__memory.html#ga932684b2222b998a00209e0967ebb13f">minerva::retrieveTensor</a>(tensor3, buffer3);</div>
<div class="ttc" id="agroup__memory_html_ga932684b2222b998a00209e0967ebb13f"><div class="ttname"><a href="group__memory.html#ga932684b2222b998a00209e0967ebb13f">minerva::retrieveTensor</a></div><div class="ttdeci">CommandHandle retrieveTensor(const TensorImp &amp;src, const BufferImp &amp;dst)</div><div class="ttdoc">Retrieves the given Tensor back from the GPU.</div></div>
<div class="ttc" id="agroup__memory_html_gabd431c08dce9b0b8cd96434a8554e99b"><div class="ttname"><a href="group__memory.html#gabd431c08dce9b0b8cd96434a8554e99b">minerva::updateTensor</a></div><div class="ttdeci">CommandHandle updateTensor(const BufferImp &amp;src, const TensorImp &amp;dst)</div><div class="ttdoc">Updates the given Tensor using the given buffer.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
3. Create Progam</h1>
<p>Next up is to tell <code>minerva</code> about the compute shader. These are managed by <code>Program</code>, so let's create one:</p>
<div class="fragment"><div class="line"><a class="code" href="classminerva_1_1_program.html">minerva::Program</a> program(context, <span class="stringliteral">&quot;compute.spv&quot;</span>);</div>
<div class="ttc" id="aclassminerva_1_1_program_html"><div class="ttname"><a href="classminerva_1_1_program.html">minerva::Program</a></div><div class="ttdoc">Program holds a compute shader and allows dispatching it.</div><div class="ttdef"><b>Definition:</b> Program.hpp:120</div></div>
</div><!-- fragment --><p>Right know, our program knows nothing about the tensors. This happens during dispatch, as we will see in a little. In Vulkan parameters are bundled into sets. By default it's set 0, so we didn't need to specify it in the compute shader. To pass the tensors to our program, we need to bind them to such a parameter set, managed by <code>Paremeter</code> created by our program:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> param = program.createParameter();</div>
<div class="line">param.setArgument(tensor1, 0);</div>
<div class="line">param.setArgument(tensor2, 1);</div>
<div class="line">param.setArgument(tensor3, 2);</div>
</div><!-- fragment --><p>We can finally create a command like the ones we created for copying data earlier for running our shader:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> run = program.Run({ 10 }, param);</div>
</div><!-- fragment --><p>See the documentation of <code>Dispatch</code> for further details.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
4. Create command sequence</h1>
<p>A quirk of Vulkan is that submitted commands are not guaranteed to finish in order and won't wait for another. This means that without coordination, our copy commands might already finished before our compute shader actually wrote any data.</p>
<p><code>minerva</code> provides the <code>Timeline</code> class, for coordinating and submitting commands, so let's start with creating one:</p>
<div class="fragment"><div class="line"><a class="code" href="classminerva_1_1_timeline.html">minerva::Timeline</a> timeline(context);</div>
<div class="ttc" id="aclassminerva_1_1_timeline_html"><div class="ttname"><a href="classminerva_1_1_timeline.html">minerva::Timeline</a></div><div class="ttdoc">Class used for controlling time dependency on commands.</div><div class="ttdef"><b>Definition:</b> Timeline.hpp:10</div></div>
</div><!-- fragment --><p><code>Timeline</code> internally holds a <code>uint64_t</code> storing the current step a sequence of commands is. Commands and the CPU can wait for the <code>Timeline</code> to reach a certain step, while commands and the CPU can raise the value. Note that the value must always be increasing. Lowering it results in an exception! See the documentation of <code>Timeline</code> for more details.</p>
<p>A simple sequence orchestrated by the newly created timeline can be done using the <code>beginSequence</code> builder function:</p>
<div class="fragment"><div class="line">minerva::beginSequence(timeline)</div>
<div class="line">    .<a class="code" href="classminerva_1_1_sequence_builder.html#a95788d74c21e4d7fe251a58dfbdc800c">And</a>(copy1)</div>
<div class="line">    .<a class="code" href="classminerva_1_1_sequence_builder.html#a95788d74c21e4d7fe251a58dfbdc800c">And</a>(copy2)</div>
<div class="line">    .<a class="code" href="classminerva_1_1_sequence_builder.html#aa0619976f00ff9e872ef786491f79632">Then</a>(run)</div>
<div class="line">    .<a class="code" href="classminerva_1_1_sequence_builder.html#aa0619976f00ff9e872ef786491f79632">Then</a>(copy3)</div>
<div class="line">    .<a class="code" href="classminerva_1_1_sequence_builder.html#a496a7f81ca15affb90baaa17df0e050a">Submit</a>();</div>
<div class="ttc" id="aclassminerva_1_1_sequence_builder_html_a496a7f81ca15affb90baaa17df0e050a"><div class="ttname"><a href="classminerva_1_1_sequence_builder.html#a496a7f81ca15affb90baaa17df0e050a">minerva::SequenceBuilder::Submit</a></div><div class="ttdeci">uint64_t Submit()</div><div class="ttdoc">Submits the sequence to the GPU.</div></div>
<div class="ttc" id="aclassminerva_1_1_sequence_builder_html_a95788d74c21e4d7fe251a58dfbdc800c"><div class="ttname"><a href="classminerva_1_1_sequence_builder.html#a95788d74c21e4d7fe251a58dfbdc800c">minerva::SequenceBuilder::And</a></div><div class="ttdeci">SequenceBuilder &amp; And(const CommandHandle &amp;command)</div><div class="ttdoc">Issues the given command running parallel in the current step.</div></div>
<div class="ttc" id="aclassminerva_1_1_sequence_builder_html_aa0619976f00ff9e872ef786491f79632"><div class="ttname"><a href="classminerva_1_1_sequence_builder.html#aa0619976f00ff9e872ef786491f79632">minerva::SequenceBuilder::Then</a></div><div class="ttdeci">SequenceBuilder &amp; Then(const CommandHandle &amp;command)</div><div class="ttdoc">Issues the given command to run after the previous step finished.</div></div>
</div><!-- fragment --><p>After submission, the CPU does not wait for the GPU to finish its work. We can use the <code>Timeline</code> to wait for it to finish, by calling <code>waitValue</code> with the final step reached after the last command:</p>
<div class="fragment"><div class="line">timeline.waitValue(3);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
